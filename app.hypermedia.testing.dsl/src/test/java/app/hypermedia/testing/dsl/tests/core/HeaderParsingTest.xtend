/*
 * generated by Xtext 2.18.0
 */
package app.hypermedia.testing.dsl.tests.core

import app.hypermedia.testing.dsl.core.CoreScenario
import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import app.hypermedia.testing.dsl.tests.CoreInjectorProvider
import app.hypermedia.testing.dsl.tests.TestHelpers
import app.hypermedia.testing.dsl.core.HeaderStatement
import app.hypermedia.testing.dsl.core.RelaxedLinkBlock
import static org.assertj.core.api.Assertions.*
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.MethodSource

@ExtendWith(InjectionExtension)
@InjectWith(CoreInjectorProvider)
class HeaderParsingTest {
    @Inject
    ParseHelper<CoreScenario> parseHelper

    @Test
    def void expectHeader_ParsesName() {
        // when
        val result = parseHelper.parse('''
            With Link "Foo" {
                Expect Header Location
            }
        ''')

        // then
        TestHelpers.assertModelParsedSuccessfully(result)

        val linkBlock = result.steps.get(0) as RelaxedLinkBlock
        val headerStatement = linkBlock.children.get(0) as HeaderStatement
        assertThat(headerStatement.fieldName).isEqualTo("Location")
    }

    @Test
    def void expectHeader_ParsesNameWithHyphen() {
        // when
        val result = parseHelper.parse('''
            With Link "Foo" {
                Expect Header Content-Location
            }
        ''')

        // then
        TestHelpers.assertModelParsedSuccessfully(result)

        val linkBlock = result.steps.get(0) as RelaxedLinkBlock
        val headerStatement = linkBlock.children.get(0) as HeaderStatement
        assertThat(headerStatement.fieldName).isEqualTo("Content-Location")
    }

    @Test
    def void expectHeader_ParsesExactValue() {
        // when
        val result = parseHelper.parse('''
            With Link "Foo" {
                Expect Header Content-Type "application/problem+json"
            }
        ''')

        // then
        TestHelpers.assertModelParsedSuccessfully(result)

        val linkBlock = result.steps.get(0) as RelaxedLinkBlock
        val headerStatement = linkBlock.children.get(0) as HeaderStatement
        assertThat(headerStatement.exactValue).isEqualTo("application/problem+json")
    }

    @Test
    def void expectHeader_ParsesRegularExpression() {
        // when
        val result = parseHelper.parse('''
            With Link "Foo" {
                Expect Header Location Matching "^http://expected.url/"
            }
        ''')

        // then
        TestHelpers.assertModelParsedSuccessfully(result)

        val linkBlock = result.steps.get(0) as RelaxedLinkBlock
        val headerStatement = linkBlock.children.get(0) as HeaderStatement
        assertThat(headerStatement.regex.pattern).isEqualTo("^http://expected.url/")
    }

    @Test
    def void expectHeader_CapturesVariable() {
        // when
        val result = parseHelper.parse('''
            With Link "Foo" {
                Expect Header Location [uri]
            }
        ''')

        // then
        TestHelpers.assertModelParsedSuccessfully(result)

        val linkBlock = result.steps.get(0) as RelaxedLinkBlock
        val headerStatement = linkBlock.children.get(0) as HeaderStatement
        assertThat(headerStatement.variable).isEqualTo("uri")
    }

    @ParameterizedTest
    @MethodSource("invalidVariableReferences")
    def void expectHeader_invalidVariableReference_parsingFails(String variable) {
        // when
        val result = parseHelper.parse('''
            With Link "Foo" {
                Expect Header Location «variable»
            }
        ''')

        // then
        TestHelpers.assertModelParsingFailed(result)
    }
    
    static def invalidVariableReferences() {
         return #[
            "[unclosed",
            "variableOnly",
            "[]",
            "unopened]"
        ]
    } 
}
